{
  "language": "Solidity",
  "sources": {
    "contracts/Collector.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport './Ownable.sol';\n\nabstract contract MonthlyPaymentsCalculatorInterface {\n  function calculatePayment(bytes32 homeId, address renterAddress)\n    external\n    virtual\n    returns (\n      uint256,\n      uint256,\n      uint256\n    );\n}\n\nabstract contract DomiInterface {\n  function transferTokens(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external payable virtual;\n\n  function transferTokensToPrincipalContract(\n    address renterAddress,\n    address principalContractAddress,\n    uint256 amount\n  ) external virtual;\n}\n\nabstract contract PrincipalInterface {\n  function transferPrincipal(address renterAddress, uint256 amount) external payable virtual;\n}\n\nabstract contract ReservesInterface {\n  function transferBuffer(uint256 amount) external payable virtual;\n}\n\ncontract Collector is Ownable {\n  MonthlyPaymentsCalculatorInterface public monthlyPaymentsCalculatorContract;\n  DomiInterface public domiContract;\n  PrincipalInterface public principalContract;\n  ReservesInterface public reservesContract;\n\n  function setMonthlyPaymentsCalculatorContractAddress(address _address) external onlyOwner {\n    monthlyPaymentsCalculatorContract = MonthlyPaymentsCalculatorInterface(_address);\n  }\n\n  function setDomiContractAddress(address _address) external onlyOwner {\n    domiContract = DomiInterface(_address);\n  }\n\n  function setPrincipalContractAddress(address _address) external onlyOwner {\n    principalContract = PrincipalInterface(_address);\n  }\n\n  function setReservesContractAddress(address _address) external onlyOwner {\n    reservesContract = ReservesInterface(_address);\n  }\n\n  struct PaymentHistory {\n    uint256 timeStamp;\n    uint256 amount;\n  }\n\n  struct MonthlyPayment {\n    uint256 savingsRate;\n    uint256 principal;\n    uint256 buffer;\n  }\n\n  mapping(address => uint256) public renterToHome; // maps renter's public address to homeId\n  mapping(address => MonthlyPayment) public renterToMonthlyPayment; // monthly payment consisting of savingsRate+principal+buffer that renter has to pay next\n  mapping(address => PaymentHistory[]) public paymentsMade; // history of payments made by renter\n  mapping(address => PaymentHistory[]) public paymentsMissed; // history of missed payments\n  mapping(address => uint256) public monthsPaid; // count of months paid by renter\n\n  function getMonthlyPaymentAmount(bytes32 homeId, address renterAddress)\n    external\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    (\n      uint256 savingsRatePayment,\n      uint256 principalPayment,\n      uint256 bufferPayment\n    ) = monthlyPaymentsCalculatorContract.calculatePayment(homeId, renterAddress);\n    renterToMonthlyPayment[renterAddress] = MonthlyPayment(\n      savingsRatePayment,\n      principalPayment,\n      bufferPayment\n    );\n    return (savingsRatePayment, principalPayment, bufferPayment);\n  }\n\n  function payMonthlyPayments(address renterAddress, uint256 amount) external payable {\n    uint256 totalPayable = renterToMonthlyPayment[renterAddress].savingsRate +\n      renterToMonthlyPayment[renterAddress].principal +\n      renterToMonthlyPayment[renterAddress].buffer;\n    require(amount >= totalPayable, 'Payment is insufficient');\n    // TODO\n    // If equal or more, inform HomeContract.sol of successful payment\n    // If less, inform HomeContract.sol of unsuccessful payment\n    domiContract.transferTokens(\n      renterAddress,\n      address(domiContract),\n      renterToMonthlyPayment[renterAddress].savingsRate\n    );\n    principalContract.transferPrincipal(\n      renterAddress,\n      renterToMonthlyPayment[renterAddress].principal\n    );\n    domiContract.transferTokens(\n      renterAddress,\n      address(reservesContract),\n      renterToMonthlyPayment[renterAddress].buffer\n    );\n    paymentsMade[renterAddress].push(PaymentHistory(block.timestamp, amount));\n    monthsPaid[renterAddress] += 1;\n  }\n\n  // TODO check every month if renter has paid. If not paid within grace period add it as a missed payment\n\n  function getMonthsPaid(address renterAddress) public view returns (uint256) {\n    return monthsPaid[renterAddress];\n  }\n}\n"
    },
    "contracts/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable {\n  address private _owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @dev Initializes the contract setting the deployer as the initial owner.\n   */\n  constructor() {\n    _owner = msg.sender;\n    emit OwnershipTransferred(address(0), _owner);\n  }\n\n  /**\n   * @dev Returns the address of the current owner.\n   */\n  function owner() public view virtual returns (address) {\n    return _owner;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(isOwner(), 'Only owner can access');\n    _;\n  }\n\n  /**\n   * @return true if `msg.sender` is the owner of the contract.\n   */\n  function isOwner() public view returns (bool) {\n    return msg.sender == _owner;\n  }\n\n  /**\n   * @dev Leaves the contract without owner. It will not be possible to call\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\n   *\n   * NOTE: Renouncing ownership will leave the contract without an owner,\n   * thereby removing any functionality that is only available to the owner.\n   */\n  function renounceOwnership() public virtual onlyOwner {\n    _transferOwnership(address(0));\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Can only be called by the current owner.\n   */\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), 'New owner is the zero address');\n    _transferOwnership(newOwner);\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Internal function without access restriction.\n   */\n  function _transferOwnership(address newOwner) internal virtual {\n    address oldOwner = _owner;\n    _owner = newOwner;\n    emit OwnershipTransferred(oldOwner, newOwner);\n  }\n}\n"
    },
    "contracts/Principal.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport './Ownable.sol';\n\nabstract contract DomiInterface {\n  function savingsRate() public view virtual returns (uint256 savingsRate);\n\n  function totalSupply() public view virtual returns (uint256 totalSupply);\n\n  function balanceOf(address whom) public view virtual returns (uint256);\n\n  function transferTokens(\n    address sender,\n    address recipient,\n    uint256 numTokens\n  ) public virtual returns (bool);\n}\n\nabstract contract ReservesInterface {\n  function transferBuffer(uint256 amount) external payable virtual;\n}\n\ncontract Principal is Ownable {\n  mapping(address => uint256) private _principalBalances;\n  mapping(address => bool) private _principalAddressInitialized;\n  address[] private _addressesWithPrincipal;\n  DomiInterface public domiContract;\n  ReservesInterface public reservesContract;\n  uint256 public savingsRateLastDistributed;\n\n  event PenaltyPaid(address from, address to, uint256 tokens);\n  event ClaimRestOfPenalty(address renterAddress, uint256 balanceOwed);\n\n  function setDomiContractAddress(address _address) external onlyOwner {\n    domiContract = DomiInterface(_address);\n  }\n\n  function setReservesContractAddress(address _address) external onlyOwner {\n    reservesContract = ReservesInterface(_address);\n  }\n\n  // TODO when savingsRate paid to Principal Contract, distribute to holders proportionately\n  function distributeSavingsRate(uint256 totalAmount) external onlyOwner {\n    require(block.timestamp - 28 days >= savingsRateLastDistributed, 'Wait at least 28 days');\n    uint256 totalPrincipal = 0;\n    // TODO take a snapshot of the current state and use this data to do the following\n    // or might pay the same entity twice? eg Person A owns first and last address in the\n    // array, when distribute fn is called, A can transfer his tokens from first to last\n    // address after the fn pays his first address but before reading the balance of his\n    // last address. Then when fn reads the balance of his last address, he will get paid\n    // again despite only having the same amount of tokens\n    for (uint256 i = 0; i < _addressesWithPrincipal.length; i++) {\n      totalPrincipal += _principalBalances[_addressesWithPrincipal[i]];\n    }\n\n    for (uint256 i = 0; i < _addressesWithPrincipal.length; i++) {\n      _principalBalances[_addressesWithPrincipal[i]] +=\n        (_principalBalances[_addressesWithPrincipal[i]] * totalAmount) /\n        totalPrincipal;\n    }\n  }\n\n  // Record principal from Collector.sol\n  function transferPrincipal(address renterAddress, uint256 amount) external payable {\n    if (_principalAddressInitialized[renterAddress] == false) {\n      _principalAddressInitialized[renterAddress] = true;\n      _addressesWithPrincipal.push(renterAddress);\n    }\n    _principalBalances[renterAddress] += amount;\n    domiContract.transferTokens(renterAddress, address(this), amount);\n  }\n\n  // When the renter terminates their contract, release the principal back to the renterAddress minus penalties\n  function transferToRenter(address renterAddress, uint256 penalty) external {\n    uint256 renterPrincipal = _principalBalances[renterAddress];\n    if (penalty > 0) {\n      if (penalty <= renterPrincipal) {\n        _principalBalances[renterAddress] = renterPrincipal - penalty;\n        domiContract.transferTokens(address(this), address(reservesContract), penalty);\n        emit PenaltyPaid(renterAddress, address(reservesContract), penalty);\n      } else {\n        _principalBalances[renterAddress] = 0;\n        domiContract.transferTokens(address(this), address(reservesContract), renterPrincipal);\n        emit PenaltyPaid(renterAddress, address(reservesContract), renterPrincipal);\n        // TODO probably need function to inform real life ops team to collect rest of penalty owed\n        emit ClaimRestOfPenalty(renterAddress, penalty - renterPrincipal);\n      }\n    }\n    uint256 netPrincipal = renterPrincipal - penalty;\n    if (netPrincipal > 0) {\n      _principalBalances[renterAddress] = 0;\n      domiContract.transferTokens(address(this), renterAddress, netPrincipal);\n    }\n  }\n\n  // TODO When the renter/homeowner pays their dues for the full length of the term (eg 30 years), transfer the principal to BuyHomes.sol\n}\n"
    },
    "contracts/MonthlyPaymentsCalculator.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport './Ownable.sol';\n\n// import 'abdk-libraries-solidity/ABDKMath64x64.sol';\n\nabstract contract DomiInterface {\n  function savingsRate() external view virtual returns (uint256 savingsRate);\n}\n\nabstract contract HomeContractsInterface {\n  function getDetails(bytes32 homeId)\n    external\n    view\n    virtual\n    returns (uint256 homePrice, uint256 term);\n}\n\nabstract contract PrincipalInterface {\n  function getPrincipal(bytes32 homeId, address renterAddress)\n    external\n    view\n    virtual\n    returns (uint256 principal);\n}\n\nabstract contract CollectorInterface {\n  function getMonthsPaid(address renterAddress) public view virtual returns (uint256);\n}\n\ncontract MonthlyPaymentsCalculator is Ownable {\n  DomiInterface public domiContract;\n  HomeContractsInterface public homeContractsContract;\n  PrincipalInterface public principalContract;\n  CollectorInterface public collecterContract;\n\n  function setDomiContractAddress(address _address) external onlyOwner {\n    domiContract = DomiInterface(_address);\n  }\n\n  function setHomeContractsContractAddress(address _address) external onlyOwner {\n    homeContractsContract = HomeContractsInterface(_address);\n  }\n\n  function setPrincipalContractAddress(address _address) external onlyOwner {\n    principalContract = PrincipalInterface(_address);\n  }\n\n  function calculatePayment(bytes32 homeId, address renterAddress)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 homePrice;\n    uint256 monthsPaid;\n    uint256 term;\n    uint256 savingsRate;\n    uint256 principal;\n    (homePrice, term) = homeContractsContract.getDetails(homeId);\n    monthsPaid = collecterContract.getMonthsPaid(renterAddress);\n    uint256 monthsLeft = term * 12 - monthsPaid;\n    savingsRate = domiContract.savingsRate();\n    principal = principalContract.getPrincipal(homeId, renterAddress);\n\n    uint256 savingsRatePayment;\n    uint256 principalPayment;\n    uint256 bufferPayment;\n    savingsRatePayment = _calculateSavingsRatePayment(homePrice, savingsRate);\n    principalPayment = _calculatePrincipalPayment(homePrice, savingsRate, monthsLeft, principal);\n    bufferPayment = _calculateBufferPayment(homePrice, savingsRate);\n    return (savingsRatePayment, principalPayment, bufferPayment);\n  }\n\n  function _calculateSavingsRatePayment(uint256 homePrice, uint256 savingsRate)\n    private\n    pure\n    returns (uint256)\n  {\n    // +1 is to round up\n    // need to divide 10^2 to get real value(still have not factored in decimals for Domi)\n    return (homePrice * savingsRate) / 12 / 10**3 + 1;\n  }\n\n  function _calculatePrincipalPayment(\n    // TODO fix bug\n    uint256 homePrice,\n    uint256 savingsRate,\n    uint256 monthsLeft,\n    uint256 principal\n  ) private pure returns (uint256) {\n    uint256 futureValueOfPrincipal = compound(principal, monthsLeft, savingsRate);\n    uint256 shortfall = homePrice - futureValueOfPrincipal;\n    // uint256 payment = calculatePMT(savingsRate, monthsLeft, principal, shortfall);\n    // return payment;\n    // for now just naively divide shortfall by monthsLeft, will factor in future monthly principal compounding next time\n    return approximate(shortfall, monthsLeft, savingsRate);\n    // shortfall -= approximate(shortfall, monthsLeft, savingsRate);\n    // return shortfall / monthsLeft;\n  }\n\n  function _calculateBufferPayment(uint256 homePrice, uint256 savingsRate)\n    private\n    pure\n    returns (uint256)\n  {\n    // Decimals = 2, need to divide 10^2 to get real value(still have not factored in decimals for Domi)\n    // +1 is to round up\n    // max(0.001 / 12 * homePrice, 0.1 * savingsRate / 12 * homePrice)\n    uint256 minBuffer = (100 * homePrice) / 12;\n    uint256 tenPercentBuffer = ((10000 * savingsRate) / 12) * homePrice;\n    if (tenPercentBuffer >= minBuffer) {\n      return tenPercentBuffer / 10**8 + 1;\n    } else {\n      return minBuffer / 10**3 + 1;\n    }\n  }\n\n  // assumes rate has 5 decimals. Rounds down.\n  // returns in 2 decimals\n  function compound(\n    uint256 principal,\n    uint256 timePeriods,\n    uint256 rate\n  ) public pure returns (uint256) {\n    principal *= 10**3;\n    for (uint256 i = 0; i < timePeriods; i++) {\n      principal += (principal * rate) / 12 / 10**5;\n    }\n    return principal / 10**3;\n  }\n\n  function approximate(\n    uint256 shortfall,\n    uint256 monthsLeft,\n    uint256 savingsRate\n  ) public pure returns (uint256) {\n    shortfall *= 1;\n    uint256 approx = shortfall / monthsLeft;\n    uint256 temp;\n    for (uint256 i = 0; i < 100; i++) {\n      temp = 0;\n      for (uint256 j = 0; j < monthsLeft; j++) {\n        temp += approx;\n        temp += (temp * savingsRate) / 12 / 10**5;\n      }\n      if (temp > shortfall) {\n        approx -= 9;\n      } else if (temp == shortfall) {\n        return approx;\n      } else {\n        return (approx + 10);\n      }\n    }\n    return approx;\n    // uint approximateMonthlyInterest = shortfall * savingsRate / 12 / 10**5;\n    // return approximateMonthlyInterest * monthsLeft / 10**3;\n  }\n\n  // function calculatePMT(\n  //   uint256 savingsRate,\n  //   uint256 monthsLeft,\n  //   uint256 principal,\n  //   uint256 shortfall\n  // ) public pure returns (uint256) {\n  //   return\n  //     ABDKMath64x64.toUInt(\n  //       pmt(\n  //         ABDKMath64x64.fromUInt(savingsRate),\n  //         ABDKMath64x64.fromUInt(monthsLeft),\n  //         ABDKMath64x64.fromUInt(principal),\n  //         ABDKMath64x64.fromUInt(shortfall)\n  //       )\n  //     );\n  // }\n\n  // function pmt(\n  //   int128 ratePerPeriod,\n  //   int128 numberOfPayments,\n  //   int128 presentValue,\n  //   int128 futureValue\n  // ) public pure returns (int128) {\n  //   ratePerPeriod = ratePerPeriod / ABDKMath64x64.fromUInt(12 * 10**5);\n  //   presentValue = ABDKMath64x64.neg(presentValue);\n\n  //   // annuity formula shortfall = PMT((1+ratePerPeriod)**numberOfPayments - 1) / ratePerPeriod\n  //   int128 firstPart = ABDKMath64x64.mul(futureValue, ratePerPeriod);\n  //   int128 secondPart = ABDKMath64x64.add(ABDKMath64x64.fromUInt(1), ratePerPeriod);\n  //   int128 thirdPart = ABDKMath64x64.pow(secondPart, ABDKMath64x64.toUInt(numberOfPayments));\n  //   int128 fourthPart = ABDKMath64x64.sub(thirdPart, ABDKMath64x64.fromUInt(1));\n  //   return ABDKMath64x64.div(firstPart, fourthPart);\n\n  //   // int128 q =\n  //   //   ABDKMath64x64.pow (\n  //   //     ABDKMath64x64.add (\n  //   //       0x10000000000000000,\n  //   //       ratePerPeriod),\n  //   //     ABDKMath64x64.toUInt (\n  //   //       numberOfPayments));\n  //   // return\n  //   //   ABDKMath64x64.neg(ABDKMath64x64.div (\n  //   //     ABDKMath64x64.mul (\n  //   //       ratePerPeriod,\n  //   //       ABDKMath64x64.add (\n  //   //         futureValue,\n  //   //         ABDKMath64x64.mul (\n  //   //           q,\n  //   //           presentValue))),\n  //   //     ABDKMath64x64.mul (\n  //   //       ABDKMath64x64.sub (\n  //   //         q,\n  //   //         0x10000000000000000),\n  //   //       ABDKMath64x64.add (\n  //   //         0x10000000000000000,\n  //   //         ratePerPeriod))));\n  // }\n\n  function testCalculatesavingsRatePayment(uint256 homePrice, uint256 savingsRate)\n    external\n    pure\n    returns (uint256)\n  {\n    return _calculateSavingsRatePayment(homePrice, savingsRate);\n  }\n\n  function testCalculatePrincipalPayment(\n    uint256 homePrice,\n    uint256 savingsRate,\n    uint256 monthsLeft,\n    uint256 principal\n  ) external pure returns (uint256) {\n    return _calculatePrincipalPayment(homePrice, savingsRate, monthsLeft, principal);\n  }\n\n  function testCalculateBufferPayment(uint256 homePrice, uint256 savingsRate)\n    external\n    pure\n    returns (uint256)\n  {\n    return _calculateBufferPayment(homePrice, savingsRate);\n  }\n}\n"
    },
    "contracts/Homes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './HomePriceCalculator.sol';\n// import './Domi.sol';\nimport './Ownable.sol';\n\nabstract contract DomiInterface {\n  function transferTokens(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external payable virtual;\n\n  function transferTokensToPrincipalContract(\n    address renterAddress,\n    address principalContractAddress,\n    uint256 amount\n  ) external virtual;\n\n  function mintWithHome(\n    address currentOwnerAddress,\n    bytes32 homeId,\n    uint256 price\n  ) public virtual;\n}\n\nabstract contract HomePriceCalculatorInterface {\n  function determineHomePrice(uint256 postalCode, string memory streetName)\n    public\n    virtual\n    returns (uint256);\n}\n\nabstract contract CollectorInterface {\n  function getMonthlyPaymentAmount(bytes32 homeId, address renterAddress)\n    external\n    virtual\n    returns (\n      uint256,\n      uint256,\n      uint256\n    );\n\n  function terminateMonthlyPayments(bytes32 homeId, address renterAddress) external virtual;\n}\n\nabstract contract PrincipalInterface {\n  function transferToRenter(address renterAddress, uint256 penalty) external virtual;\n\n  function paymentToReserve(address renterAddress) external virtual;\n}\n\nabstract contract MonthlyPaymentsCalculatorInterface {\n  function calculatePayment(bytes32 homeId, address renterAddress) external virtual;\n}\n\nstruct Home {\n  bytes32 homeId;\n  address renterAddress;\n  address homeOwnerAddress;\n  uint256 housePrice;\n  string streetName;\n  uint256 postalCode;\n  uint256 lease;\n  bool minted;\n  bool rented;\n}\n\ncontract Homes is Ownable {\n  DomiInterface public domiContract;\n  HomePriceCalculator public homePriceCalculator;\n  CollectorInterface public collectorContract;\n  MonthlyPaymentsCalculatorInterface public monthlyPmtCalculator;\n  PrincipalInterface public principalContract;\n  uint256 public confirmedHomeCount;\n  uint256 public unconfirmedHomeCount;\n  mapping(bytes32 => Home) public homes;\n  mapping(bytes32 => Home) public unconfirmedHomes;\n  bytes32[] public unconfirmedHomeIds;\n  bytes32[] public unrentedHomeIds;\n\n  constructor() public {\n    // domi = new Domi();\n    homePriceCalculator = new HomePriceCalculator();\n  }\n\n  function setDomiContractAddress(address _address) external onlyOwner {\n    domiContract = DomiInterface(_address);\n  }\n\n  function getHousePrice(string memory streetName, uint256 postalCode) public returns (uint256) {\n    return homePriceCalculator.determineHomePrice(postalCode, streetName);\n  }\n\n  function addHome(\n    address currentOwnerAddress,\n    string memory streetName,\n    uint256 postalCode\n  ) public {\n    Home memory home;\n    home.homeId = generateHomeId(streetName, postalCode);\n    home.homeOwnerAddress = currentOwnerAddress;\n    home.streetName = streetName;\n    home.postalCode = postalCode;\n    home.housePrice = getHousePrice(streetName, postalCode);\n    home.minted = false;\n    home.rented = false;\n    unconfirmedHomes[home.homeId] = home;\n    homes[home.homeId] = home;\n    unconfirmedHomeCount += 1;\n  }\n\n  // TODO: checkUnconfirmedHomeExpire():\n\n  function confirmHome(bytes32 homeId, address currentOwnerAddress) public {\n    // TODO: Allow current owner sign\n    if (homes[homeId].homeOwnerAddress != currentOwnerAddress)\n      revert('Home owner address does not tally with owner address in contract');\n    if (homes[homeId].minted == true) revert('Home already minted');\n    delete unconfirmedHomes[homeId];\n    for (uint256 i = 0; i < unconfirmedHomeCount; i++) {\n      if (unconfirmedHomeIds[i] == homeId) {\n        unconfirmedHomeIds[i] = unconfirmedHomeIds[unconfirmedHomeCount - 1];\n        delete unconfirmedHomeIds[unconfirmedHomeCount - 1];\n        // TODO: Test length of array, might need to remove last element\n      }\n    }\n    homes[homeId].minted = true;\n    confirmedHomeCount += 1;\n    domiContract.mintWithHome(currentOwnerAddress, homeId, homes[homeId].housePrice);\n  }\n\n  function minted(bytes32 homeId) public view returns (bool) {\n    return homes[homeId].minted;\n  }\n\n  function getHomeCount() public view returns (uint256) {\n    return confirmedHomeCount;\n  }\n\n  function generateHomeId(string memory streetName, uint256 postalCode)\n    public\n    pure\n    returns (bytes32)\n  {\n    return keccak256(abi.encodePacked(streetName, postalCode));\n  }\n\n  function renterSign(\n    bytes32 homeId,\n    address renterAddress,\n    uint256 lease\n  ) public {\n    homes[homeId].rented = true;\n    homes[homeId].lease = lease;\n    homes[homeId].renterAddress = renterAddress;\n    unrentedHomeIds.push(homeId);\n  }\n\n  function schedulePayments(bytes32 homeId, address renterAddress) public {\n    uint256 savingsRatePayment;\n    uint256 principalPayment;\n    uint256 bufferPayment;\n    (savingsRatePayment, principalPayment, bufferPayment) = collectorContract\n      .getMonthlyPaymentAmount(homeId, renterAddress);\n  }\n\n  function terminateContract(\n    bytes32 homeId,\n    address renterAddress,\n    uint256 penalty\n  ) public {\n    collectorContract.terminateMonthlyPayments(homeId, renterAddress);\n    principalContract.transferToRenter(renterAddress, penalty);\n  }\n\n  function transferHome(bytes32 homeId, address renterAddress) public {\n    // TODO: offchain transfer\n    delete homes[homeId];\n    confirmedHomeCount -= 1;\n    principalContract.paymentToReserve(renterAddress);\n  }\n\n  function getDetails(bytes32 homeId) external view returns (uint256 homePrice, uint256 term) {\n    return (homes[homeId].housePrice, homes[homeId].lease);\n  }\n}\n"
    },
    "contracts/HomePriceCalculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract HomePriceCalculator {\n  event HomePriceReceived(uint256 housePrice);\n\n  function determineHomePrice(uint256 postalCode, string memory streetName)\n    public\n    returns (uint256)\n  {\n    uint256 housePrice = 10000;\n    if (compareStrings(streetName, 'Orchard')) {\n      housePrice += 10000;\n    }\n    if (postalCode % 2 == 0) {\n      housePrice += 1000;\n    } // if even\n    emit HomePriceReceived(housePrice);\n    return housePrice;\n  }\n\n  function compareStrings(string memory a, string memory b) public view returns (bool) {\n    return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n  }\n}\n"
    },
    "contracts/Domi.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport './Ownable.sol';\n\nabstract contract PrincipalInterface {\n  function distributeSavingsRate(uint256 amount) external virtual;\n}\n\nabstract contract Homes {\n  function minted(bytes32 homeId) public virtual returns (bool);\n}\n\ncontract DomiToken is ERC20, Ownable {\n  Homes private homes;\n  address private _owner;\n  address[] private _domiHolders;\n  mapping(address => bool) private _addressInitialized;\n  address private _recipient;\n  uint256 public savingsRate;\n  uint256 public lastDistributed;\n  uint256 public numOfHolders;\n\n  PrincipalInterface public principalContract;\n\n  function setPrincipalContractAddress(address _address) external onlyOwner {\n    principalContract = PrincipalInterface(_address);\n  }\n\n  constructor() public ERC20('DomiToken', 'Domi') {\n    _mint(msg.sender, 100 * (10**uint256(decimals())));\n    _owner = msg.sender;\n    lastDistributed = block.timestamp;\n    numOfHolders = 0;\n  }\n\n  function transferTokens(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public {\n    if (_addressInitialized[recipient] == false) {\n      _addressInitialized[recipient] = true;\n      // TODO is it possible the same address is pushed more than once to _domiHolders?\n      // crucial as distribute fn relies on it or the same address can be paid more than once\n      _domiHolders.push(recipient);\n    }\n    if (recipient == address(principalContract)) {\n      principalContract.distributeSavingsRate(amount);\n    }\n    _transfer(sender, recipient, amount);\n    //  _approve(sender, msg.sender, allowance[sender][msg.sender].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n    // return true;\n  }\n\n  function getTokenOwner() public view returns (address) {\n    return _owner;\n  }\n\n  function isSufficient() external view returns (bool) {\n    uint256 totalSavingsRateOwed = totalSupply() * savingsRate;\n    if (totalSavingsRateOwed <= balanceOf(address(this))) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function distribute() external onlyOwner {\n    require(block.timestamp - 28 days >= lastDistributed, 'Wait at least 28 days');\n    // TODO take a snapshot of the current state and use this data to do the following\n    // or might pay the same entity twice? eg Person A owns first and last address in the\n    // array, when distribute fn is called, A can transfer his tokens from first to last\n    // address after the fn pays his first address but before reading the balance of his\n    // last address. Then when fn reads the balance of his last address, he will get paid\n    // again despite only having the same amount of tokens\n    uint256 totalSavingsRateOwed = totalSupply() * savingsRate;\n    require(totalSavingsRateOwed <= balanceOf(address(this)), 'Insufficient to pay savings rate');\n    uint256 numDomiHolders = _domiHolders.length;\n    for (uint256 i = 0; i < numDomiHolders; i++) {\n      // if recipient is principal contract, let it update its balances first before transferring\n      if (_domiHolders[i] == address(principalContract)) {\n        principalContract.distributeSavingsRate(\n          (balanceOf(_domiHolders[i]) * totalSavingsRateOwed) / totalSupply()\n        );\n      }\n      transferTokens(\n        address(this),\n        _domiHolders[i],\n        (balanceOf(_domiHolders[i]) * totalSavingsRateOwed) / totalSupply()\n      );\n    }\n  }\n\n  function mintWithHome(\n    address currentOwnerAddress,\n    bytes32 homeId,\n    uint256 price\n  ) public onlyOwner returns (bool) {\n    // Mint domi and transfer to owner after home deposit\n    if (homes.minted(homeId)) {\n      // TODO: implement mint\n      // domi.mint(currentOwnerAddress, price);\n      return true;\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/DomiMockToken.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract DomiMockToken is ERC20 {\n    address private _owner;\n    uint256 public lastDistributed;\n    uint256 public numOfHolders;\n    mapping(address => bool) private _addressInitialized;\n    address[] private _domiHolders;\n\n\n    constructor() ERC20('DomiToken', 'Domi') {\n      uint256 initialSupply = 100;\n      _mint(msg.sender, initialSupply);\n      _owner = msg.sender;\n      lastDistributed = block.timestamp;\n      numOfHolders = 0;\n    }\n}"
    },
    "contracts/Distributor.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport './Ownable.sol';\n\nabstract contract DomiInterface {\n  function getStabilityFee() public view virtual returns (uint256 stabilityFee);\n\n  function getTotalSupply() public view virtual returns (uint256 totalSupply);\n\n  function balanceOf(address whom) public view virtual returns (uint256);\n}\n\ncontract Distributor is Ownable {\n  uint256 public lastDistributed;\n  address[] public domiHolders;\n  DomiInterface public domiContract;\n  mapping(address => uint256) public balances;\n\n  constructor() {\n    lastDistributed = block.timestamp;\n  }\n\n  function setDomiContractAddress(address _address) external onlyOwner {\n    domiContract = DomiInterface(_address);\n  }\n\n  function isSufficient() external view returns (bool) {\n    uint256 stabilityFee = domiContract.getStabilityFee();\n    uint256 totalStabilityFeesOwed = domiContract.getTotalSupply() * stabilityFee;\n    if (totalStabilityFeesOwed <= domiContract.balanceOf(address(this))) {\n      return true;\n    }\n    return false;\n  }\n\n  function distribute() external onlyOwner {\n    require(block.timestamp - 28 days >= lastDistributed, 'Wait at least 28 days');\n    uint256 stabilityFee = domiContract.getStabilityFee();\n    uint256 totalSupply = domiContract.getTotalSupply();\n    uint256 totalStabilityFeesOwed = totalSupply * stabilityFee;\n    require(\n      totalStabilityFeesOwed <= domiContract.balanceOf(address(this)),\n      'Insufficient stability fees'\n    );\n    // uint256 numDomiHolders = domiHolders.length;\n    // for (uint256 i = 0; i < numDomiHolders; i++) {\n    //   // TODO transfer(address(this), domiHolders[i], balances[domiHolders[i]] / totalSupply * totalStabilityFeesOwed);\n    // }\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}